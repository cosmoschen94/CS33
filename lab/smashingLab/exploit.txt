In order to exploit the thttpd-no and delete a file in the working directory, we need to
find a way to make the program return to an address containing the sys_unlink machine
instruction, which then deletes the file according to the value of rdi register, which
should be the address of the first character of C-string "target.txt". Next, in order
to make the program return to wherever we want, we need to figure out the offset
between rsp and rbp registers. Once we figure out the offset, we can pass in the right
number of bytes and overwrite the return address with our desired address.

In my case, I first read through the thttpd-no.s file and I find that the offset between
rsp and rbp is 152 bytes. I then write a python script called exploit.py, which
creates a config-no.txt that includes many placeholder characters. Then I pass this
config-no.txt into ./thttpd-no under gdb. I set a breakpoint at fclose. Then use gdb to
print out the next 50 words in hex after rsp register. I record the two addresses between
the address of rsp and that of rbp for storing machine instructions of sys_unlink and
C-string "target.txt". Then I create a file named "insns.s" and use command objdump to
find out the hexidecimal values for these machine instructions. I also look at the ASCII
table to convert all the hexidecimal values for addresses, machine instructions and characters
into oct values. Then put them into exploit.py in specific order. Finally, when I pass the
newly generated config-no.txt file into ./thttpd-no under gdb and run till the program return,
the program reaches the machine instructions I inject and successfully delete the file "target.txt"
in my working directory.
